// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\CustArch_v16\process_and_retrieve.v
// Created: 2021-06-21 17:49:55
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: process_and_retrieve
// Source Path: CustArch_v16/cust_architecture/process_and_retrieve
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module process_and_retrieve
          (clk,
           reset,
           enb,
           rd_address,
           current_value,
           source_device,
           InputState,
           address_for_processing,
           rd_out);


  input   clk;
  input   reset;
  input   enb;
  input   [8:0] rd_address;  // ufix9
  input   [15:0] current_value;  // uint16
  input   [2:0] source_device;  // ufix3
  input   [7:0] InputState;  // uint8
  input   [8:0] address_for_processing;  // ufix9
  output  [15:0] rd_out;  // uint16


  reg [2:0] Memory_out1;  // ufix3
  wire Compare_To_Constant_out1;
  wire Compare_To_Constant1_out1;
  reg  Memory2_out1;
  wire Logical_Operator_out1;
  wire [15:0] FilterChip1_out1_0;  // uint16
  wire [15:0] FilterChip1_out1_1;  // uint16
  wire [15:0] FilterChip1_out1_2;  // uint16
  wire [8:0] Data_Type_Conversion1_out1;  // ufix9
  wire Data_Type_Conversion_out1;
  wire [15:0] PreviousData1_storage_out1;  // uint16
  wire [15:0] previous_sample;  // uint16

  // The dual-port RAM in the input interpret subsystem introduces 
  // a sample of delay. Furthermore, I need one sample more of delay
  // due to the IIR filter --> overall delay of two samples
  // 
  // generally, all sample in the processing subsystem
  // are delayed by two samples --> the memories are 
  // needed for this reason
  // 
  // data sent for processing
  // 
  // address sent for processing
  // 
  // rd_address from Output


  always @(posedge clk or posedge reset)
    begin : Memory_process
      if (reset == 1'b1) begin
        Memory_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          Memory_out1 <= source_device;
        end
      end
    end



  assign Compare_To_Constant_out1 = Memory_out1 == 3'b000;



  assign Compare_To_Constant1_out1 = InputState == 8'b00000111;



  always @(posedge clk or posedge reset)
    begin : Memory2_process
      if (reset == 1'b1) begin
        Memory2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Memory2_out1 <= Compare_To_Constant1_out1;
        end
      end
    end



  assign Logical_Operator_out1 = Compare_To_Constant_out1 & Memory2_out1;



  FilterChip1 u_FilterChip1 (.clk(clk),
                             .reset(reset),
                             .enb(enb),
                             .current_value(current_value),  // uint16
                             .filter_enable(Logical_Operator_out1),
                             .address_for_processing(address_for_processing),  // ufix9
                             .filtered_data_0(FilterChip1_out1_0),  // uint16
                             .filtered_data_1(FilterChip1_out1_1),  // uint16
                             .filtered_data_2(FilterChip1_out1_2)  // uint16
                             );

  assign Data_Type_Conversion1_out1 = FilterChip1_out1_1[8:0];



  assign Data_Type_Conversion_out1 = (FilterChip1_out1_2 != 16'b0000000000000000 ? 1'b1 :
              1'b0);



  DualPortRAM_generic #(.AddrWidth(9),
                        .DataWidth(16)
                        )
                      u_PreviousData1_storage (.clk(clk),
                                               .enb(enb),
                                               .wr_din(FilterChip1_out1_0),
                                               .wr_addr(Data_Type_Conversion1_out1),
                                               .wr_en(Data_Type_Conversion_out1),
                                               .rd_addr(rd_address),
                                               .wr_dout(PreviousData1_storage_out1),
                                               .rd_dout(previous_sample)
                                               );

  assign rd_out = previous_sample;

endmodule  // process_and_retrieve

