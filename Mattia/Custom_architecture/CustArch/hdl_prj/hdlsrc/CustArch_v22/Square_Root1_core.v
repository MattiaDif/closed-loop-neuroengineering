// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\CustArch_v22\Square_Root1_core.v
// Created: 2021-09-20 12:48:51
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Square_Root1_core
// Source Path: CustArch_v22/cust_architecture/process_and_retrieve/spike_detection/LocalMaximaAdaptiveThreshold/RMS_computation/Square 
// Root1/Square Root1_cor
// Hierarchy Level: 6
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Square_Root1_core
          (clk,
           reset,
           enb,
           xin,
           ain,
           xout,
           aout);


  input   clk;
  input   reset;
  input   enb;
  input   signed [39:0] xin;  // sfix40_En36
  input   [39:0] ain;  // ufix40_En40
  output  signed [39:0] xout;  // sfix40_En36
  output  [39:0] aout;  // ufix40_En40


  wire signed [39:0] const3;  // sfix40_En36
  wire signed [43:0] amul;  // sfix44_En40
  wire signed [83:0] mul1_mul_temp;  // sfix84_En76
  wire signed [39:0] mulout1;  // sfix40_En36
  reg signed [39:0] mulout1delay;  // sfix40_En36
  wire signed [43:0] delaymul;  // sfix44_En40
  reg signed [39:0] xindelay1;  // sfix40_En36
  wire signed [83:0] mul2_mul_temp;  // sfix84_En76
  wire signed [39:0] mulout2;  // sfix40_En36
  reg signed [39:0] mulout2delay;  // sfix40_En36
  wire signed [39:0] subout;  // sfix40_En36
  wire signed [39:0] shiftout;  // sfix40_En36
  reg signed [39:0] shiftoutdelay;  // sfix40_En36
  wire signed [43:0] shiftmul;  // sfix44_En40
  reg signed [39:0] xindelay3_reg_reg [0:1];  // sfix40 [2]
  wire signed [39:0] xindelay3_reg_reg_next [0:1];  // sfix40_En36 [2]
  wire signed [39:0] xindelay3;  // sfix40_En36
  wire signed [83:0] mul2_mul_temp_1;  // sfix84_En76
  wire signed [39:0] mulout3;  // sfix40_En36
  reg signed [39:0] xout_1;  // sfix40_En36
  reg [39:0] aout_reg_reg [0:3];  // ufix40 [4]
  wire [39:0] aout_reg_reg_next [0:3];  // ufix40_En40 [4]

  // Iteration Core of the RecipSqrt Implementation using Newton Method


  assign const3 = 40'sh3000000000;



  assign amul = {4'b0, ain};



  assign mul1_mul_temp = amul * xin;
  assign mulout1 = mul1_mul_temp[79:40] + $signed({1'b0, mul1_mul_temp[39]});



  always @(posedge clk or posedge reset)
    begin : xinterm1_reg_process
      if (reset == 1'b1) begin
        mulout1delay <= 40'sh0000000000;
      end
      else begin
        if (enb) begin
          mulout1delay <= mulout1;
        end
      end
    end



  assign delaymul = {mulout1delay, 4'b0000};



  always @(posedge clk or posedge reset)
    begin : xindelay1_reg_process
      if (reset == 1'b1) begin
        xindelay1 <= 40'sh0000000000;
      end
      else begin
        if (enb) begin
          xindelay1 <= xin;
        end
      end
    end



  assign mul2_mul_temp = delaymul * xindelay1;
  assign mulout2 = mul2_mul_temp[79:40] + $signed({1'b0, mul2_mul_temp[39]});



  always @(posedge clk or posedge reset)
    begin : xinterm2_reg_process
      if (reset == 1'b1) begin
        mulout2delay <= 40'sh0000000000;
      end
      else begin
        if (enb) begin
          mulout2delay <= mulout2;
        end
      end
    end



  assign subout = const3 - mulout2delay;



  assign shiftout = subout >>> 8'd1;



  always @(posedge clk or posedge reset)
    begin : xinterm3_reg_process
      if (reset == 1'b1) begin
        shiftoutdelay <= 40'sh0000000000;
      end
      else begin
        if (enb) begin
          shiftoutdelay <= shiftout;
        end
      end
    end



  assign shiftmul = {shiftoutdelay, 4'b0000};



  always @(posedge clk or posedge reset)
    begin : xindelay3_reg_process
      if (reset == 1'b1) begin
        xindelay3_reg_reg[0] <= 40'sh0000000000;
        xindelay3_reg_reg[1] <= 40'sh0000000000;
      end
      else begin
        if (enb) begin
          xindelay3_reg_reg[0] <= xindelay3_reg_reg_next[0];
          xindelay3_reg_reg[1] <= xindelay3_reg_reg_next[1];
        end
      end
    end

  assign xindelay3 = xindelay3_reg_reg[1];
  assign xindelay3_reg_reg_next[0] = xindelay1;
  assign xindelay3_reg_reg_next[1] = xindelay3_reg_reg[0];



  assign mul2_mul_temp_1 = shiftmul * xindelay3;
  assign mulout3 = mul2_mul_temp_1[79:40] + $signed({1'b0, mul2_mul_temp_1[39]});



  always @(posedge clk or posedge reset)
    begin : xout_reg_process
      if (reset == 1'b1) begin
        xout_1 <= 40'sh0000000000;
      end
      else begin
        if (enb) begin
          xout_1 <= mulout3;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : aout_reg_process
      if (reset == 1'b1) begin
        aout_reg_reg[0] <= 40'h0000000000;
        aout_reg_reg[1] <= 40'h0000000000;
        aout_reg_reg[2] <= 40'h0000000000;
        aout_reg_reg[3] <= 40'h0000000000;
      end
      else begin
        if (enb) begin
          aout_reg_reg[0] <= aout_reg_reg_next[0];
          aout_reg_reg[1] <= aout_reg_reg_next[1];
          aout_reg_reg[2] <= aout_reg_reg_next[2];
          aout_reg_reg[3] <= aout_reg_reg_next[3];
        end
      end
    end

  assign aout = aout_reg_reg[3];
  assign aout_reg_reg_next[0] = ain;
  assign aout_reg_reg_next[1] = aout_reg_reg[0];
  assign aout_reg_reg_next[2] = aout_reg_reg[1];
  assign aout_reg_reg_next[3] = aout_reg_reg[2];



  assign xout = xout_1;

endmodule  // Square_Root1_core

