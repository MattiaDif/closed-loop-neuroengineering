// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\CustArch_v24\channel_threshold.v
// Created: 2021-09-23 14:17:17
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: channel_threshold
// Source Path: CustArch_v24/cust_architecture/process_and_retrieve/pipe_in_interpret/channel_threshold
// Hierarchy Level: 3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module channel_threshold
          (clk,
           reset,
           enb,
           InputState,
           In1,
           th);


  input   clk;
  input   reset;
  input   enb;
  input   [7:0] InputState;  // uint8
  input   [15:0] In1;  // uint16
  output  [15:0] th;  // uint16


  reg [15:0] Delay2_out1;  // uint16
  reg [15:0] Delay2_out1_1;  // uint16
  reg [15:0] Delay2_out1_2;  // uint16
  wire [7:0] Cast_out1;  // uint8
  reg [7:0] Delay4_reg [0:1];  // ufix8 [2]
  wire [7:0] Delay4_reg_next [0:1];  // ufix8 [2]
  wire [7:0] Delay4_out1;  // uint8
  wire Relational_Operator_relop1;
  reg  Delay6_out1;
  wire [15:0] Constant_out1;  // uint16
  wire Relational_Operator1_relop1;
  reg  Delay3_out1;
  wire Logical_Operator_out1;
  reg  Delay7_out1;
  wire read_from_porcessing;
  reg [7:0] HDL_Counter_out1;  // uint8
  wire input_state_AC1_out1;
  reg  Delay1_out1;
  reg [7:0] Delay8_reg [0:4];  // ufix8 [5]
  wire [7:0] Delay8_reg_next [0:4];  // ufix8 [5]
  wire [7:0] Delay8_out1;  // uint8
  wire [15:0] Dual_Port_RAM_out1;  // uint16
  wire [15:0] Dual_Port_RAM_out2;  // uint16


  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= In1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        Delay2_out1_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1_1 <= Delay2_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reduced_1_process
      if (reset == 1'b1) begin
        Delay2_out1_2 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1_2 <= Delay2_out1_1;
        end
      end
    end



  assign Cast_out1 = Delay2_out1_1[7:0];



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_reg[0] <= 8'b00000000;
        Delay4_reg[1] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay4_reg[0] <= Delay4_reg_next[0];
          Delay4_reg[1] <= Delay4_reg_next[1];
        end
      end
    end

  assign Delay4_out1 = Delay4_reg[1];
  assign Delay4_reg_next[0] = Cast_out1;
  assign Delay4_reg_next[1] = Delay4_reg[0];



  assign Relational_Operator_relop1 = Delay2_out1 != Delay2_out1_1;



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= Relational_Operator_relop1;
        end
      end
    end



  assign Constant_out1 = 16'b0000000010000000;



  assign Relational_Operator1_relop1 = Delay2_out1_1 < Constant_out1;



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Relational_Operator1_relop1;
        end
      end
    end



  assign Logical_Operator_out1 = Delay6_out1 & Delay3_out1;



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= Logical_Operator_out1;
        end
      end
    end



  assign read_from_porcessing = InputState == 8'b00000111;



  assign input_state_AC1_out1 = HDL_Counter_out1 == 8'b10011111;



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= input_state_AC1_out1;
        end
      end
    end



  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  always @(posedge clk or posedge reset)
    begin : HDL_Counter_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          if (Delay1_out1 == 1'b1) begin
            HDL_Counter_out1 <= 8'b00000000;
          end
          else if (read_from_porcessing == 1'b1) begin
            HDL_Counter_out1 <= HDL_Counter_out1 + 8'b00000001;
          end
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_reg[0] <= 8'b00000000;
        Delay8_reg[1] <= 8'b00000000;
        Delay8_reg[2] <= 8'b00000000;
        Delay8_reg[3] <= 8'b00000000;
        Delay8_reg[4] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay8_reg[0] <= Delay8_reg_next[0];
          Delay8_reg[1] <= Delay8_reg_next[1];
          Delay8_reg[2] <= Delay8_reg_next[2];
          Delay8_reg[3] <= Delay8_reg_next[3];
          Delay8_reg[4] <= Delay8_reg_next[4];
        end
      end
    end

  assign Delay8_out1 = Delay8_reg[4];
  assign Delay8_reg_next[0] = HDL_Counter_out1;
  assign Delay8_reg_next[1] = Delay8_reg[0];
  assign Delay8_reg_next[2] = Delay8_reg[1];
  assign Delay8_reg_next[3] = Delay8_reg[2];
  assign Delay8_reg_next[4] = Delay8_reg[3];



  DualPortRAM_generic #(.AddrWidth(8),
                        .DataWidth(16)
                        )
                      u_Dual_Port_RAM (.clk(clk),
                                       .enb(enb),
                                       .wr_din(Delay2_out1_2),
                                       .wr_addr(Delay4_out1),
                                       .wr_en(Delay7_out1),
                                       .rd_addr(Delay8_out1),
                                       .wr_dout(Dual_Port_RAM_out1),
                                       .rd_dout(Dual_Port_RAM_out2)
                                       );

  assign th = Dual_Port_RAM_out2;

endmodule  // channel_threshold

