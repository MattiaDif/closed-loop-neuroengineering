// -------------------------------------------------------------
// 
// File Name: C:\GitHub\closed-loop-neuroscience\Mattia\Custom_architecture\Verilog\CustArch\get_enabled_timings.v
// Created: 2021-03-29 11:16:01
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: get_enabled_timings
// Source Path: CustArch/cust_architecture/output_interpret/Interpret_to_RAM_output/get enabled timings 
// Hierarchy Level: 3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module get_enabled_timings
          (clk,
           reset,
           enb,
           output_state,
           data_stream_en,
           source_channel_en,
           source_ch_0_159,
           source_device_enabled,
           source_device,
           converter_cnt);


  input   clk;
  input   reset;
  input   enb;
  input   [7:0] output_state;  // uint8
  input   [7:0] data_stream_en;  // uint8
  output  source_channel_en;
  output  [7:0] source_ch_0_159;  // uint8
  output  source_device_enabled;  // ufix1
  output  [2:0] source_device;  // ufix3
  output  [2:0] converter_cnt;  // ufix3


  wire Compare_To_Constant2_out1;
  wire Compare_To_Constant1_out1;
  wire Compare_To_Constant_out1;
  reg [7:0] HDL_Counter1_out1;  // uint8
  wire Compare_To_Zero_out1;
  wire switch_compare_1;
  reg  Memory2_out1;
  wire switch_compare_1_1;
  wire Detect_Change_out1;
  wire [7:0] Triggered_Subsystem_out1;  // uint8
  reg [7:0] Memory1_out1;  // uint8
  wire [7:0] Switch2_out1;  // uint8
  wire Compare_To_Constant3_out1;
  wire OR_out1;
  wire [7:0] Switch1_out1;  // uint8
  wire Bit_Slice1_out1;  // ufix1
  wire AND_out1;
  wire Compare_To_Constant4_out1;
  wire Compare_To_Constant5_out1;
  wire AND1_out1;
  reg [7:0] HDL_Counter_out1;  // uint8
  wire y;  // ufix1
  wire [7:0] Subsystem_out2;  // uint8
  wire [2:0] Bit_Slice2_out1;  // ufix3
  wire Compare_To_Constant6_out1;
  wire Compare_To_Constant7_out1;
  wire AND2_out1;
  reg [7:0] HDL_Counter3_out1;  // uint8
  wire [2:0] Bit_Slice3_out1;  // ufix3

  // I think that If I manage to get the local counters from stateflow I would be able to avoid most of the stuff here!!
  // 
  // enabling it only if you're in the right output_state
  // 
  // It works (at least with one headstage) but need to check 'cause I'm not sure about those delays.. do they work 
  // with hdl


  assign Compare_To_Constant2_out1 = output_state == 8'b00000110;



  assign Compare_To_Constant1_out1 = output_state == 8'b00001000;



  assign Compare_To_Constant_out1 = output_state == 8'b00000111;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 159
  always @(posedge clk or posedge reset)
    begin : HDL_Counter1_process
      if (reset == 1'b1) begin
        HDL_Counter1_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          if (Compare_To_Constant1_out1 == 1'b1) begin
            HDL_Counter1_out1 <= 8'b00000000;
          end
          else if (Compare_To_Constant_out1 == 1'b1) begin
            if (HDL_Counter1_out1 >= 8'b10011111) begin
              HDL_Counter1_out1 <= 8'b00000000;
            end
            else begin
              HDL_Counter1_out1 <= HDL_Counter1_out1 + 8'b00000001;
            end
          end
        end
      end
    end



  assign Compare_To_Zero_out1 = HDL_Counter1_out1 == 8'b00000000;



  assign switch_compare_1 = Compare_To_Zero_out1 > 1'b0;



  always @(posedge clk or posedge reset)
    begin : Memory2_process
      if (reset == 1'b1) begin
        Memory2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Memory2_out1 <= Compare_To_Zero_out1;
        end
      end
    end



  assign switch_compare_1_1 = Memory2_out1 > 1'b0;



  Detect_Change u_Detect_Change (.clk(clk),
                                 .reset(reset),
                                 .enb(enb),
                                 .U(HDL_Counter1_out1),  // uint8
                                 .Y(Detect_Change_out1)
                                 );

  always @(posedge clk or posedge reset)
    begin : Memory1_process
      if (reset == 1'b1) begin
        Memory1_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Memory1_out1 <= Triggered_Subsystem_out1;
        end
      end
    end



  assign Switch2_out1 = (switch_compare_1_1 == 1'b0 ? Memory1_out1 :
              data_stream_en);



  Triggered_Subsystem_block u_Triggered_Subsystem (.clk(clk),
                                                   .reset(reset),
                                                   .enb(enb),
                                                   .In1(Switch2_out1),  // uint8
                                                   .Trigger(Detect_Change_out1),
                                                   .Out1(Triggered_Subsystem_out1)  // uint8
                                                   );

  assign Compare_To_Constant3_out1 = output_state == 8'b00000111;



  assign OR_out1 = Compare_To_Constant2_out1 | Compare_To_Constant3_out1;



  assign Switch1_out1 = (switch_compare_1 == 1'b0 ? Triggered_Subsystem_out1 :
              data_stream_en);



  assign Bit_Slice1_out1 = Switch1_out1[0];



  assign AND_out1 = OR_out1 & Bit_Slice1_out1;



  assign source_channel_en = AND_out1;

  assign source_ch_0_159 = HDL_Counter1_out1;

  assign Compare_To_Constant4_out1 = output_state >= 8'b00001000;



  assign Compare_To_Constant5_out1 = output_state <= 8'b00001011;



  assign AND1_out1 = Compare_To_Constant4_out1 & Compare_To_Constant5_out1;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7
  always @(posedge clk or posedge reset)
    begin : HDL_Counter_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          if (AND1_out1 == 1'b1) begin
            if (HDL_Counter_out1 >= 8'b00000111) begin
              HDL_Counter_out1 <= 8'b00000000;
            end
            else begin
              HDL_Counter_out1 <= HDL_Counter_out1 + 8'b00000001;
            end
          end
        end
      end
    end



  Subsystem_block u_Subsystem (.counter(HDL_Counter_out1),  // uint8
                               .data_stream_en(data_stream_en),  // uint8
                               .source_device_en(y),  // ufix1
                               .source_device(Subsystem_out2)  // uint8
                               );

  assign source_device_enabled = y;

  assign Bit_Slice2_out1 = Subsystem_out2[2:0];



  assign source_device = Bit_Slice2_out1;

  assign Compare_To_Constant6_out1 = output_state >= 8'b00001100;



  assign Compare_To_Constant7_out1 = output_state <= 8'b00001101;



  assign AND2_out1 = Compare_To_Constant6_out1 & Compare_To_Constant7_out1;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7
  always @(posedge clk or posedge reset)
    begin : HDL_Counter3_process
      if (reset == 1'b1) begin
        HDL_Counter3_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          if (AND2_out1 == 1'b1) begin
            if (HDL_Counter3_out1 >= 8'b00000111) begin
              HDL_Counter3_out1 <= 8'b00000000;
            end
            else begin
              HDL_Counter3_out1 <= HDL_Counter3_out1 + 8'b00000001;
            end
          end
        end
      end
    end



  assign Bit_Slice3_out1 = HDL_Counter3_out1[2:0];



  assign converter_cnt = Bit_Slice3_out1;

endmodule  // get_enabled_timings

